# 装逼刷题法

## 写在前面
面试是交流，细节在外企面试中需特别注意

* “三”思：
	* 	题目听清楚
	*  时间&空间复杂度要求
	*  是否能修改原有数据结构（比如链表结构在递归的过程中可能会被修改）
	*  是否能使用系统函数
* 后行：
	*	时间复杂度优化靠算法，空间复杂度优化靠细节
	* 	系统函数是否能手写
	*  测试用例是否能手写


#### 基础模板
* 遍历模板：
	* [中序（前后改一下do代码即可）](https://blog.csdn.net/weixin_45047081/article/details/115796199?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-115796199-blog-110820799.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-115796199-blog-110820799.pc_relevant_aa&utm_relevant_index=1) 
	* [后序](https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/acm-xuan-shou-tu-jie-leetcode-er-cha-shu-q9ep/)	
* BFS&DFS模板：https://leetcode.cn/problems/path-sum-ii/solution/tao-mo-ban-er-cha-shu-wen-ti-de-dfs-he-bfs-jie-fa-/
* 二分查找模板：https://leetcode.cn/circle/discuss/ooxfo8
* DP：https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/

#### 题型模板
* TopK问题：https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/by-flix-amc8/

#### API

* 队列
```
初始化
queue = deque()
queue = deque([(root)])
操作
queue.append()
queue.popleft()
```

* 字典
```
初始化
dict = dict()

操作
dict[root.key] = root.val
```

* 栈

### [3] 无重复字符的最长子串

```
https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

#### 通用：滑动窗口 O(N)，O(∣Σ∣)，其中Σ表示字符集（即字符串中可以出现的字符）
```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 哈希集合，记录每个字符是否出现过
        occ = set()
        n = len(s)
        # 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        rk, ans = -1, 0
        for i in range(n):
            if i != 0:
                # 左指针向右移动一格，移除一个字符
                occ.remove(s[i - 1])
            while rk + 1 < n and s[rk + 1] not in occ:
                # 不断地移动右指针
                occ.add(s[rk + 1])
                rk += 1
            # 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = max(ans, rk - i + 1)
        return ans
```

### [42] 接雨水
```
https://leetcode-cn.com/problems/trapping-rain-water/description/

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

示例:

输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```
#### Low: 单调栈 O(n)，O(n)
```
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        stack = list()
        n = len(height)
        
        for i, h in enumerate(height):
            while stack and h > height[stack[-1]]:
                top = stack.pop()
                if not stack:
                    break
                left = stack[-1]
                currWidth = i - left - 1
                currHeight = min(height[left], height[i]) - height[top]
                ans += currWidth * currHeight
            stack.append(i)
        
        return ans
```

#### High: 双指针 O(n)，O(1)
左右高度，小的为王，同侧相减，加进总和

```
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        left, right = 0, len(height) - 1
        leftMax = rightMax = 0

        while left < right:
            leftMax = max(leftMax, height[left])
            rightMax = max(rightMax, height[right])
            if height[left] < height[right]:
                ans += leftMax - height[left]
                left += 1
            else:
                ans += rightMax - height[right]
                right -= 1
        
        return ans
```

### [121] 买卖股票的最佳时机系列

```
真特么牛逼
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
⁠    注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。


示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

我们要跳出固有的思维模式，并不是要考虑买还是卖，而是要最大化手里持有的钱。
买股票手里的钱减少，卖股票手里的钱增加，无论什么时刻，我们要保证手里的钱最多。

我们这一次买还是卖只跟上一次我们卖还是买的状态有关。

#### 121. 买卖股票的最佳时机
```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        buy, sell = -float("inf"), 0

        for p in prices:
            # buy的变化其实和sell无关，可视为遍历算最大值
            buy = max(buy, 0 - p)
            sell = max(sell, buy + p)

        return sell
```

#### 122. 买卖股票的最佳时机
这两个问题唯一的不同点在于我们是买一次还是买无穷多次，而代码就只有 0-p 和 sell-p 的区别。
因为如果买无穷多次，就需要上一次卖完的状态。如果只买一次，那么上一个状态一定是0。

```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        buy, sell = -float("inf"), 0

        for p in prices:
            # buy会受上次sell的影响
            buy = max(buy, sell - p)
            sell = max(sell, buy + p)

        return sell

```

#### 123. 买卖股票的最佳时机
这题只允许最多买两次，那么就有四个状态，第一次买，第一次卖，第二次买，第二次卖。
还是那句话，无论什么状态，我们要保证手里的钱最多。

```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        b1, b2, s1, s2 = -float("inf"), -float("inf"), 0, 0

        for p in prices:
            b1 = max(b1, 0 - p)
            s1 = max(s1, b1 + p)
            b2 = max(b2, s1 - p)
            s2 = max(s2, b2 + p)
            
        return s2
```

#### 188. 买卖股票的最佳时机
上三题最多两次我们有2x2个状态，那么k次我们就需要kx2个状态。
那么我们并不需要像第三题那样真的列kx2个参数，我们只需要两个数组就可以了。

```
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        k = min(k, len(prices) // 2)

        buy = [-float("inf")] * (k+1)
        sell = [0] * (k+1)

        for p in prices:
            for i in range(1, k+1):
                buy[i] = max(buy[i], sell[i-1] - p)
                sell[i] = max(sell[i], buy[i] + p)

        return sell[-1]

```


```
定义
buy[i][j] 表示对于数组 prices[0..i] 中的价格而言，进行恰好 j 笔交易，并且当前手上持有一支股票，这种情况下的最大利润；用 sell[i][j] 表示恰好进行 j 笔交易，并且当前手上不持有股票，这种情况下的最大利润。

初始化
buy[0][0], sell[0][0] = -prices[0], 0
for i in range(1, k + 1):
    buy[0][i]  = float("-inf")
    sell[0][i] = 0


转移方程
buy[i][j] = max(buy[i - 1][j], sell[i - 1][j] - prices[i])
sell[i][j] = max(sell[i - 1][j], buy[i - 1][j - 1] + prices[i]);  



class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0

        n = len(prices)
        k = min(k, n // 2)
        buy = [[0] * (k + 1) for _ in range(n)]
        sell = [[0] * (k + 1) for _ in range(n)]

        buy[0][0], sell[0][0] = -prices[0], 0
        for i in range(1, k + 1):
            buy[0][i]  = float("-inf")
            sell[0][i] = 0

        for i in range(1, n):
            buy[i][0] = max(buy[i - 1][0], sell[i - 1][0] - prices[i])
            for j in range(1, k + 1):
                # buy[i - 1][j] = 本次不买，sell[i - 1][j] - prices[i] = 本次买
                buy[i][j] = max(buy[i - 1][j], sell[i - 1][j] - prices[i])
                sell[i][j] = max(sell[i - 1][j], buy[i - 1][j - 1] + prices[i]);  

        return max(sell[n - 1])
```

#### 309. 最佳买卖股票时机含冷冻期
这道题只是122的变形，卖完要隔一天才能买，那么就多记录上一次卖的状态即可。


```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        buy, sell_pre, sell = -float("inf"), 0, 0

        for p in prices:
            buy = max(buy, sell_pre - p)
            sell_pre, sell = sell, max(sell, buy + p)
                 
        return sell
```

#### 714. 买卖股票的最佳时机含手续费
每次买卖需要手续费，那么我们买的时候减掉手续费就行了。

```
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:

        buy, sell = -float("inf"), 0

        for p in prices:
            buy = max(buy, sell - p - fee)
            sell = max(sell, buy + p)
        
        return sell
```
### [199] 二叉树的右视图

```
https://leetcode-cn.com/problems/binary-tree-right-side-view/description/

algorithms
Medium (64.92%)
Likes:    507
Dislikes: 0
Total Accepted:    124.2K
Total Submissions: 191K
Testcase Example:  '[1,2,3,null,5,null,4]'

给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。



示例 1:




输入: [1,2,3,null,5,null,4]
输出: [1,3,4]


示例 2:


输入: [1,null,3]
输出: [1,3]
```

#### 层次遍历+hashmap巧取同层最后一个 

```
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        rightmost_value_at_depth = dict() # 深度为索引，存放节点的值
        max_depth = -1

        queue = deque([(root, 0)])
        while queue:
            node, depth = queue.popleft()

            if node is not None:
                # 维护二叉树的最大深度
                max_depth = max(max_depth, depth)

                # 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可
                rightmost_value_at_depth[depth] = node.val

                queue.append((node.left, depth + 1))
                queue.append((node.right, depth + 1))

        return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]
```


#### 反向层次遍历+setdefault

```
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        rightmost_value_at_depth = dict() # 深度为 索引，存放节点的值
        max_depth = -1

        queue = deque([(root, 0)])
        while queue:
            node, depth = queue.popleft()

            if node is not None:
                # 维护二叉树的最大深度
                max_depth = max(max_depth, depth)

                # setdefault相当于get, 不改变原有值，除非没有key
                rightmost_value_at_depth.setdefault(depth, node.val)
                
                # 从右到左
                queue.append((node.right, depth + 1))
                queue.append((node.left, depth + 1))

        return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]
```

### 剑指 Offer 12. 矩阵中的路径

```
https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
示例 2：

输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

#### LOW 基础回溯+DFS

```
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(i, j, k):
            # 用来判断程序是否越界，还有第一个字母是否匹配，第一个都不匹配直接返回False
            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k]:  return False
            # 当程序跑到word的最后一个字母时，这时无需再dfs，直接返回True
            if k == len(word) - 1: return True
            # 把访问过的字母标记为空，这样可以避免程序多次访问同一元素
            board[i][j] = ""
            # 剪枝顺序：下、上、右、左
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            # 一趟dfs结束后把原来设的空改回来，以免影响后面的dfs遍历使用
            board[i][j] = word[k]
            return res 
        # 一个一个字母来尝试，每一次尝试都是dfs遍历成功的一种可能性
        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i, j, 0): return True
        # 遍历完成，仍没有成功的路径，返回False
        return False
```

#### High 问是否支持变更数组，上面解法其实已经支持无修改原数组，但问多一句有好处
```
```

### [232] 用栈实现队列

```
https://leetcode-cn.com/problems/implement-queue-using-stacks/description/

algorithms
Easy (68.87%)
Likes:    446
Dislikes: 0
Total Accepted:    142.3K
Total Submissions: 206.2K
Testcase Example:  '["MyQueue","push","push","peek","pop","empty"]\n[[],[1],[2],[],[],[]]'

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：


void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false

说明：
你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty
操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

进阶：

你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。
示例：

输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false

提示：
最多调用 100 次 push、pop、peek 和 empty
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）
```

#### O(1), O(1)

```
class MyQueue:
    def __init__(self):
        self.stack1 = list()
        self.stack2 = list()

    def push(self, x: int) -> None:
        # self.stack1用于接受元素
        self.stack1.append(x)

    def pop(self) -> int:
        # self.stack2用于弹出元素，如果self.stack2为[],则将self.stack1中元素全部弹出给self.stack2
        if self.stack2 == []:
            while self.stack1:
                tmp = self.stack1.pop()
                self.stack2.append(tmp)
        return self.stack2.pop()

    def peek(self) -> int:
        if self.stack2 == []:
            while self.stack1:
                tmp = self.stack1.pop()
                self.stack2.append(tmp)
        return self.stack2[-1]

    def empty(self) -> bool:
        return self.stack1 == [] and self.stack2 == []
```

### [155] 最小栈
没啥好说的，基础python中取队列尾部用下标-1就OK

```
https://leetcode-cn.com/problems/min-stack/description/
设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) -- 将元素 x 推入栈中。
pop() -- 删除栈顶的元素。
top() -- 获取栈顶元素。
getMin() -- 检索栈中的最小元素。
```

#### 双栈：O(1）,O(N)
```
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, x: int) -> None:
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]: 
            self.min_stack.append(x)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

### [105] 从前序与中序遍历序列构造二叉树

```
https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/

algorithms
Medium (69.68%)
Likes:    1038
Dislikes: 0
Total Accepted:    193.8K
Total Submissions: 278.1K
Testcase Example:  '[3,9,20,15,7]\n[9,3,15,20,7]'

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：

⁠   3
⁠  / \
⁠ 9  20
⁠   /  \
⁠  15   7



@lc code=start
Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

#### 入门：递归 O(N) 、O(N)
```
list.index(列表中某个值) 求下标

```
```
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder or not inorder:  # 递归终止条件
            return
        root = TreeNode(preorder[0])  # 先序为“根左右”，所以根据preorder可以确定root
        idx = inorder.index(preorder[0])  # 中序为“左根右”，根据root可以划分出左右子树
        # 下面递归对root的左右子树求解即可
        root.left = self.buildTree(preorder[1:1 + idx], inorder[:idx])
        root.right = self.buildTree(preorder[1 + idx:], inorder[idx + 1:])
        return root
```

#### 进阶：主动构造测试用例
```
# 构建树（将输入的列表转化为一棵二叉树，返回根节点）
def deserialize(data):
    def dfs(data):
        val = data.pop(0)
        if val == 'null':
            return None

        node = TreeNode(val)
        node.left = dfs(data)
        node.right = dfs(data)
        return node
    return dfs(data)
```


### [5] 最长回文子串
```
https://leetcode-cn.com/problems/longest-palindromic-substring/description/

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。


示例 2：

输入: "cbbd"
输出: "bb"
```

#### 入门： 二维数组DP + 夹层，O(N^2)、O(N^2)
遍历每个字符，让后定义一个函数从当前字符往两边走，前后指针处的字符相同则继续（要注意计数回文串和偶数回文串）

```
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        if n < 2:
            return s
        
        max_len = 1
        begin = 0
        # dp[i][j] 表示 s[i..j] 是否是回文串
        dp = [[False] * n for _ in range(n)]
        for i in range(n):
            dp[i][i] = True
        
        # 递推开始
        # 先枚举子串长度
        for L in range(2, n + 1):
            # 枚举左边界，左边界的上限设置可以宽松一些
            for i in range(n):
                # 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                j = L + i - 1
                # 如果右边界越界，就可以退出当前循环
                if j >= n:
                    break
                    
                if s[i] != s[j]:
                    dp[i][j] = False 
                else:
                    if j - i < 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j - 1]
                
                # 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if dp[i][j] and j - i + 1 > max_len:
                    max_len = j - i + 1
                    begin = i
        return s[begin:begin + max_len]
```

### [101] 对称二叉树
```
https://leetcode-cn.com/problems/symmetric-tree/description/

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

⁠   1
⁠  / \
⁠ 2   2
⁠/ \ / \
3  4 4  3

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

⁠   1
⁠  / \
⁠ 2   2
⁠  \   \
⁠  3    3
```

#### 入门：递归 O(n)、O(n)
左右子树确实的case判定完后，递归check是否对称

```
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def fun(left,right):
            if left and not right:
                return False
            elif not left and right:
                return False
            elif not left and not right:
                return True
            else:
                return left.val==right.val and fun(left.left,right.right) and fun(left.right,right.left)
        
        if not root:
            return True
        flag=fun(root.left,root.right)
        return flag
```
#### 进阶：迭代 O(n)、O(n)

```
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        # 使用队列-先进先出
        if root == None:
            return True
        
        q = [(root.left,root.right)]
        while q != []:
            left,right = q.pop(0)
            if left == None and right == None:
                continue
            
            if left and right and left.val == right.val:
                # 将左右孩子添加入队列
                q.append((left.left,right.right))
                q.append((left.right,right.left))
            else:
                return False
        
        return True
```

### [198] 打家劫舍

```
https://leetcode-cn.com/problems/house-robber/description/

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1：
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
偷窃到的最高金额 = 1 + 3 = 4 。

示例 2：
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

#### 入门：DP O(n)、O(n)

```

* 定义子问题
* 写出子问题的递推关系
* 确定 DP 数组的计算顺序
* 空间优化（可选）

class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums :
            return 0
        n = len(nums)
        if n == 1:
            return nums[0]
        dp = [0] * n
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, n):
            dp[i] = max(dp[i-2] + nums[i], dp[i-1])
        
        return dp[n-1]
```

#### 进阶：DP + 滚动数组 O(n)、O(1)
其实和股票问题有点像，不用纯DP可以优化空间复杂度。

每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。

```
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0

        size = len(nums)
        if size == 1:
            return nums[0]
        
        first, second = nums[0], max(nums[0], nums[1])
        for i in range(2, size):
            first, second = second, max(first + nums[i], second)
        
        return second
```

### [2100] 适合打劫银行的日子


#### 入门：DP，计算连续非递增和非递减 O(n)、O(n)

```
题目中第 i 天适合野炊需满足：第 i 天前连续 time 天建议出行指数都是非递增与第 i 天后连续 time 天建议出行指数都是非递减。只需要预先计算出第 i 天前建议出行指数连续非递增的天数以及第 i 天后建议出行指数连续非递减的天数即可判断第 i 天是否适合野炊。

class Solution:
    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:
        n = len(security)
        left = [0] * n
        right = [0] * n
        for i in range(1, n):
            if security[i] <= security[i - 1]:
                left[i] = left[i - 1] + 1
            if security[n - i - 1] <= security[n - i]:
                right[n - i - 1] = right[n - i] + 1
        return [i for i in range(time, n - time) if left[i] >= time and right[i] >= time]
```

### [69] x 的平方根
```
https://leetcode-cn.com/problems/sqrtx/description/

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

输入: 4
输出: 2

示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
由于返回类型是整数，小数部分将被舍去。
```

#### 入门：二分查找 O(logN)、O(1)

```
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r, ans = 0, x, -1
        while l <= r:
            mid = (l + r) // 2
            if mid * mid <= x:
                ans = mid
                l = mid + 1
            else:
                r = mid - 1
        return ans
```

#### 进阶：牛顿迭代 O(logN)、O(1)
看不懂，背就对了

```
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return 0
        
        C, x0 = float(x), float(x)
        while True:
            xi = 0.5 * (x0 + C / x0)
            if abs(x0 - xi) < 1e-7:
                break
            x0 = xi
        
        return int(x0)
```

### [剑22] 链表中倒数第k个节点

```
输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。
```
#### 入门： 双指针 O(N)、O(1)

让你K步又何妨

```
class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:
        fast, slow = head, head

        while fast and k > 0:
            fast, k = fast.next, k - 1
        while fast:
            fast,slow = fast.next,slow.next
        
        return slow
```

### [169] 多数元素

```
https://leetcode-cn.com/problems/majority-element/description/

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1:
输入: [3,2,3]
输出: 3

示例 2:
输入: [2,2,1,1,1,2,2]
输出: 2
```

#### 哈希表 O(N)、O(N)

```
from collections import Counter

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        counts = collections.Counter(nums)
        return max(counts.keys(), key=counts.get)

```

#### 摩尔投票法 

候选人(cand_num)初始化为nums[0]，票数count初始化为1。
当遇到与cand_num相同的数，则票数count = count + 1，否则票数count = count - 1。
当票数count为0时，更换候选人，并将票数count重置为1。
遍历完数组后，cand_num即为最终答案。

为何这行得通呢？
投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1。
且“多数元素”的个数> ⌊ n/2 ⌋，其余元素的个数总和<= ⌊ n/2 ⌋。
因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 >= 1。
这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。

无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人。

```
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 0
        candidate = None

        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)

        return candidate
```

### [142] 环形链表 II

```
https://leetcode-cn.com/problems/linked-list-cycle-ii/description/

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。
示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：

输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：

输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。
```

#### 入门： 快慢指针 O(N)、O(1)
在快慢指针相遇后，将快指针置为head，然后都一步一步走

```
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast, slow = head, head
        while True:
            if not (fast and fast.next): return
            fast, slow = fast.next.next, slow.next
            if fast == slow: break
        fast = head
        while fast != slow:
            fast, slow = fast.next, slow.next
            # 不可以，因为第一个while的时候就有可能fast == slow, 导致没有任何return
            # if fast == slow:
            #     return fast
        return fast
```

### [88] 合并两个有序数组
```
https://leetcode-cn.com/problems/merge-sorted-array/description/

给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

说明:


初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。


示例:

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

### 入门：正向双指针 O(m+n)、O(m+n)

```
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        sorted = []
        p1, p2 = 0, 0
        while p1 < m or p2 < n:
            if p1 == m:
                sorted.append(nums2[p2])
                p2 += 1
            elif p2 == n:
                sorted.append(nums1[p1])
                p1 += 1
            elif nums1[p1] < nums2[p2]:
                sorted.append(nums1[p1])
                p1 += 1
            else:
                sorted.append(nums2[p2])
                p2 += 1
        nums1[:] = sorted
```

### 进阶：逆向双指针 O(m+n)、O(1)

从后往前是指从一个数组m+n-1这个位置开始倒推，而不是m-1/n-1的位置，是最终的位置

```
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        p1, p2 = m - 1, n - 1
        tail = m + n - 1
        while p1 >= 0 or p2 >= 0:
            if p1 == -1:
                nums1[tail] = nums2[p2]
                p2 -= 1
            elif p2 == -1:
                nums1[tail] = nums1[p1]
                p1 -= 1
            elif nums1[p1] > nums2[p2]:
                nums1[tail] = nums1[p1]
                p1 -= 1
            else:
                nums1[tail] = nums2[p2]
                p2 -= 1
            tail -= 1
```

### [239] 滑动窗口最大值

```
https://leetcode-cn.com/problems/sliding-window-maximum/description/
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k
个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

示例 1：


输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
⁠1 [3  -1  -3] 5  3  6  7       3
⁠1  3 [-1  -3  5] 3  6  7       5
⁠1  3  -1 [-3  5  3] 6  7       5
⁠1  3  -1  -3 [5  3  6] 7       6
⁠1  3  -1  -3  5 [3  6  7]      7


示例 2：

输入：nums = [1], k = 1
输出：[1]

示例 3：

输入：nums = [1,-1], k = 1
输出：[1,-1]

示例 4：

输入：nums = [9,11], k = 2
输出：[11]

示例 5：

输入：nums = [4,-2], k = 2
输出：[4]
```

#### 入门：堆

heapq.heapify(q)堆的操作
原理有点拗口，就是每次维护一个大顶堆，注意不要被窗口大小限制思想，这道题不用理固定堆的大小就为K，只需要看堆顶的最大值是否在当前窗口即可
当滑动窗口移动时，若最大值不在窗口，那就弹出去，否则一值滑动一直往堆里加元素就好了

```
from heapq import * 

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        # 注意 Python 默认的优先队列是小根堆
        q = [(-nums[i], i) for i in range(k)]
        heapq.heapify(q)

        ans = [-q[0][0]]
        for i in range(k, n):
            heapq.heappush(q, (-nums[i], i))
            while q[0][1] <= i - k:
                heapq.heappop(q)
            ans.append(-q[0][0])
        
        return ans
```

#### 进阶：双端队列

```
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ans = []
        dq = deque()
        
        for i in range(len(nums)):
            # 只要当前遍历的元素的值比队尾大，让队尾出队列，
            # 最终队列中的最小元素是大于当前元素的
            while dq and dq[-1] < nums[i]:
                dq.pop()
            # 当前遍历的元素入队列， 此时队列中的元素一定是有序的，队列头部最大
            dq.append(nums[i])
            if i >= k - 1:
                # 如果窗口即将失效（下一次循环要失效）的值与当前对列头部的值相同，那么将对头的值出队列，
                # 注意只pop一次，可能两个4，相邻同时是最大值，
                ans.append(dq[0])
                # 从队列中删除即将失效的数据
                if nums[i - k + 1] == dq[0]:
                    dq.popleft()
        return ans
```


#### 大师：手撸轮子

```
from typing import List

class LinkNode:
    def __init__(self, val=0):
        self.prev = None
        self.next = None
        self.val = val

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ans = []
        if k > len(nums):
            return nums
        self.head = LinkNode()
        self.tail = LinkNode()
        self.head.next = self.tail
        self.tail.prev = self.head

        for i in range(len(nums)):
            # 判空注意是tail.prev.prev
            while self.tail.prev.prev and self.get_queue_last_node().val < nums[i]:
                self.remove_node_from_tail()
            self.add_node_to_tail(LinkNode(nums[i]))
            if 0 <= i - k + 1:
                ans.append(self.get_queue_first_node().val)
                if nums[i - k + 1] == self.get_queue_first_node().val:
                    self.pop_the_leftest_node()
        return ans

    def add_node_to_tail(self, node: LinkNode):

        node.next = self.tail
        node.prev = self.tail.prev
        self.tail.prev.next = node
        self.tail.prev = node

    def get_queue_first_node(self):
        return self.head.next

    def get_queue_last_node(self):
        return self.tail.prev

    def pop_the_leftest_node(self):

        self.head.next.next.prev = self.head
        self.head.next = self.head.next.next

    def remove_node_from_tail(self):

        self.tail.prev.prev.next = self.tail
        self.tail.prev = self.tail.prev.prev
```


### [287] 寻找重复数

```
https://leetcode-cn.com/problems/find-the-duplicate-number/description/

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。

你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。


示例 1：
输入：nums = [1,3,4,2,2]
输出：2

示例 2：
输入：nums = [3,1,3,4,2]
输出：3

示例 3：
输入：nums = [1,1]
输出：1

示例 4：
输入：nums = [1,1,2]
输出：1
提示：


1 
nums.length == n + 1
1 
nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次
```

#### 入门：啥都不问直接干,直接二分

二分查找的思路是先猜一个数（有效范围 [left..right] 里位于中间的数 mid），然后统计原始数组中 小于等于 mid 的元素的个数 cnt：

如果 cnt 严格大于 mid。根据抽屉原理，重复元素就在区间 [left..mid] 里；
否则，重复元素就在区间 [mid + 1..right] 里。

```
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        left = 1
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            cnt = 0
            for num in nums:
                if num <= mid:
                    cnt += 1
            if cnt > mid:
                right = mid
            else:
                left = mid + 1
        return left
```

#### 进阶：问清楚是否支持该原数组, 升级成二进制

```
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        bit = 0
        for v in nums:
            pos = 1 << v
            if bit & pos:
                return v
            bit |= pos
```

#### 大师：问清楚是否支持该原数组, 然后改用快慢指针

```
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow = fast = cir_start = 0
        while True:
            fast = nums[nums[fast]]
            slow = nums[slow]
            if fast == slow:
                break

        while True:
            slow = nums[slow]
            cir_start = nums[cir_start]
            if cir_start == slow:
                return slow
```


### [25] K 个一组翻转链表

```
https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description/

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

进阶：
你可以设计一个只使用常数额外空间的算法来解决此问题吗？
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

示例 1：
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]

示例 2：
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]

示例 3：
输入：head = [1,2,3,4,5], k = 1
输出：[1,2,3,4,5]

示例 4：
输入：head = [1], k = 1
输出：[1]
```

#### 入门：基础反转, 递归
```
def reverseList(self, head: ListNode) -> ListNode:
    if head is None or head.next is None:
        return head
    
    p = self.reverseList(head.next)
    # head.next.next是为了回环，逆向的第一步
    head.next.next = head
    # 彻底断开当前指向下个节点的路线，让上一步的回环指到自己身上形成逆转
    head.next = None

    return p
		
```

#### 入门：基础反转, 迭代
```
def reverseList(self, head: ListNode) -> ListNode:
    prev, curr = None, head
    while curr is not None:
        next = curr.next
        curr.next = prev
        prev = curr
        curr = next
    return prev
		
```

#### 进阶： 虚拟头结点
```
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        virtual_head = ListNode()
        virtual_head.next = head
        prev = virtual_head

        while head:
            tail = prev
            for i in range(k):
                tail = tail.next
                if not tail:
                    return virtual_head.next
            next_node = tail.next
            head, tail = self.reverse(head, tail)
            prev.next = head
            tail.next = next_node
            prev = tail
            head = next_node
        return virtual_head.next
    
    def reverse(self, head, tail):
        prev = tail.next

        cur = head
        while prev != tail:
            temp = cur.next
            cur.next = prev
            prev = cur
            cur = temp
        return prev, head
```


### [415] 字符串相加

```
https://leetcode-cn.com/problems/add-strings/description/

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

num1 和num2 的长度都小于 5100
num1 和num2 都只包含数字 0-9
num1 和num2 都不包含任何前导零
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式
```

#### 入门：字符串相加 O(max(M,N))，O(1)

```
    def addStrings(self, num1: str, num2: str) -> str:
        res = ""
        i, j, carry = len(num1) - 1, len(num2) - 1, 0
        while while i>=0 or j >= 0 or carry != 0:
            n1 = int(num1[i]) if i >= 0 else 0
            n2 = int(num2[j]) if j >= 0 else 0
            tmp = n1 + n2 + carry
            carry = tmp // 10
            res = str(tmp % 10) + res
            i, j = i - 1, j - 1
        return "1" + res if carry else res
```

### [354] 俄罗斯套娃信封问题

```
给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。

当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

示例 1：

输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
示例 2：

输入：envelopes = [[1,1],[1,1],[1,1]]
输出：1
```

#### 入门：普通DP，排序

```
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        if not envelopes:
            return 0
        
        n = len(envelopes)
        envelopes.sort(key=lambda x: (x[0], -x[1]))

        f = [1] * n
        for i in range(n):
            for j in range(i):
                if envelopes[j][1] < envelopes[i][1]:
                    f[i] = max(f[i], f[j] + 1)
        
        return max(f)
```

#### 进阶：二分DP

```
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        if not envelopes:
            return 0
        
        n = len(envelopes)
        envelopes.sort(key=lambda x: (x[0], -x[1]))

        f = [envelopes[0][1]]
        for i in range(1, n):
        // 赋值并判断
            if (num := envelopes[i][1]) > f[-1]:
                f.append(num)
            else:
                index = bisect.bisect_left(f, num)
                f[index] = num
        
        return len(f)
```

### [206] 反转链表

#### 入门：迭代

```
def reverseList(self, head: ListNode) -> ListNode:
    prev, cur = None, head
    while cur != None:
        next = cur.next
        cur.next = prev
        prev = cur
        cur = next
    return prev
```

#### 入门2：递归

```
def reverseList(self, head: ListNode) -> ListNode:
    if not head or head.next == None:
        return head
    // 先把head.next（包括head.next）之后全反转了，返回新头结点，没包含head
    new_head = self.reverseList(head.next)
    // 要让A->B<-C变成A<-B<-C
    head.next.next = new_head
    // 割舍
    head.next = None
    
    return prev
```


### [106] 相交链表

#### 入门：双指针

```
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:
            return None
        virtual_head_a = headA
        virtual_head_b = headB  
        while(virtual_head_a != virtual_head_b):
            virtual_head_a = virtual_head_a.next if virtual_head_a else headB
            virtual_head_b = virtual_head_b.next if virtual_head_b else headA
        return virtual_head_a
```

### [146] LRU

#### 入门：
```
class LRUCache(collections.OrderedDict):

    def __init__(self, capacity: int):
        super().__init__()
        self.capacity = capacity


    def get(self, key: int) -> int:
        if key not in self:
            return -1
        self.move_to_end(key)
        return self[key]

    def put(self, key: int, value: int) -> None:
        if key in self:
            self.move_to_end(key)
        self[key] = value
        if len(self) > self.capacity:
            self.popitem(last=False)
```

#### 进阶：哈希表+双向链表
```
class DLinkedNode:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None


class LRUCache:

    def __init__(self, capacity: int):
        self.cache = dict()
        # 使用伪头部和伪尾部节点    
        self.head = DLinkedNode()
        self.tail = DLinkedNode()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.capacity = capacity
        self.size = 0

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        # 如果 key 存在，先通过哈希表定位，再移到头部
        node = self.cache[key]
        self.moveToHead(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key not in self.cache:
            # 如果 key 不存在，创建一个新的节点
            node = DLinkedNode(key, value)
            # 添加进哈希表
            self.cache[key] = node
            # 添加至双向链表的头部
            self.addToHead(node)
            self.size += 1
            if self.size > self.capacity:
                # 如果超出容量，删除双向链表的尾部节点
                removed = self.removeTail()
                # 删除哈希表中对应的项
                self.cache.pop(removed.key)
                self.size -= 1
        else:
            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node = self.cache[key]
            node.value = value
            self.moveToHead(node)
    
    def addToHead(self, node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def removeNode(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def moveToHead(self, node):
        self.removeNode(node)
        self.addToHead(node)

    def removeTail(self):
        node = self.tail.prev
        self.removeNode(node)
        return node
```

### [20] 有效括号

#### 入门：字典的基础用法

```
class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) % 2 == 1:
            return False
        parenthesesMap = {
            ")" : "(",
            "}" : "{",
            "]" : "["
        }

        stack = list()
        for tempChar in s:
            if tempChar in parenthesesMap:
                if not stack or stack[-1] != parenthesesMap[tempChar]:
                    return False
                stack.pop()
            else:
                stack.append(tempChar)
        return not stack   
```

### [300] 最长上升子序列

#### 入门：动态规划 O(n^2)，O(n)
```
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        dp = []
        for i in range(len(nums)):
            dp.append(1)
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

#### 进阶：贪心 + 二分查找 O(nlogn)，O(n)
```
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        dp = []
        for i in range(len(nums)):
            dp.append(1)
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

### [236] 二叉树的最近公共祖先

#### 入门：递归 O(n)，O(n)

```
class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        if not root or root == p or root == q: return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if not left: return right
        if not right: return left
        return root
```

#### 进阶：递归+哈希 O(n)，O(n)可能会少于
```
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        dic = {root:None}
        def dfs(node):
            if node:
                if node.left: 
                    dic[node.left] = node
                if node.right: 
                    dic[node.right] = node
                dfs(node.left)
                dfs(node.right)
        dfs(root)
        l1, l2 = p, q
        while(l1!=l2):
            l1 = dic.get(l1, q)
            l2 = dic.get(l2, p)
        return l1 
```

### [200] 岛屿数量

#### 入门：DFS O(mn)，O(mn)

```
class Solution:
    def dfs(self, grid, r, c):
        grid[r][c] = 0
        nr, nc = len(grid), len(grid[0])
        for x, y in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:
            if 0 <= x < nr and 0 <= y < nc and grid[x][y] == "1":
                self.dfs(grid, x, y)

    def numIslands(self, grid: List[List[str]]) -> int:
        nr = len(grid)
        if nr == 0:
            return 0
        nc = len(grid[0])

        num_islands = 0
        for r in range(nr):
            for c in range(nc):
                if grid[r][c] == "1":
                    num_islands += 1
                    self.dfs(grid, r, c)
        
        return num_islands
```

#### 进阶：BFS O(mn)，O(min(m,n))

```
class Solution:
    def dfs(self, grid, r, c):
        grid[r][c] = 0
        nr, nc = len(grid), len(grid[0])
        for x, y in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:
            if 0 <= x < nr and 0 <= y < nc and grid[x][y] == "1":
                self.dfs(grid, x, y)

    def numIslands(self, grid: List[List[str]]) -> int:
        nr = len(grid)
        if nr == 0:
            return 0
        nc = len(grid[0])

        num_islands = 0
        for r in range(nr):
            for c in range(nc):
                if grid[r][c] == "1":
                    num_islands += 1
                    self.dfs(grid, r, c)
        
        return num_islands
```

#### 亮点：并查集 O(mn * a(mn))  α(x)<=5，O(mn)

```
class UnionFind:
    def __init__(self, grid):
        m, n = len(grid), len(grid[0])
        self.count = 0
        self.parent = [-1] * (m * n)
        self.rank = [0] * (m * n)
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "1":
                    self.parent[i * n + j] = i * n + j
                    self.count += 1
    
    def find(self, i):
        if self.parent[i] != i:
            self.parent[i] = self.find(self.parent[i])
        return self.parent[i]
    
    def union(self, x, y):
        rootx = self.find(x)
        rooty = self.find(y)
        if rootx != rooty:
            if self.rank[rootx] < self.rank[rooty]:
                rootx, rooty = rooty, rootx
            self.parent[rooty] = rootx
            if self.rank[rootx] == self.rank[rooty]:
                self.rank[rootx] += 1
            self.count -= 1
    
    def getCount(self):
        return self.count

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        nr = len(grid)
        if nr == 0:
            return 0
        nc = len(grid[0])
        uf = UnionFind(grid)
        num_islands = 0
        for r in range(nr):
            for c in range(nc):
                if grid[r][c] == "1":
                    grid[r][c] = "0"
                    for x, y in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:
                        if 0 <= x < nr and 0 <= y < nc and grid[x][y] == "1":
                            uf.union(r * nc + c, x * nc + y)
        
        return uf.getCount()
```

### [54] 螺旋矩阵

#### 入门：模拟 O(mn), O(mn)
```
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return list()
        
        rows, columns = len(matrix), len(matrix[0])
        visited = [[False] * columns for _ in range(rows)]
        total = rows * columns
        order = [0] * total

		 // 顺序固定，右下左上
        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        row, column = 0, 0
        directionIndex = 0
        for i in range(total):
            order[i] = matrix[row][column]
            visited[row][column] = True
            nextRow, nextColumn = row + directions[directionIndex][0], column + directions[directionIndex][1]
            if not (0 <= nextRow < rows and 0 <= nextColumn < columns and not visited[nextRow][nextColumn]):
                directionIndex = (directionIndex + 1) % 4
            row += directions[directionIndex][0]
            column += directions[directionIndex][1]
        return order
```

> 一点浅拷贝的知识：https://wenku.baidu.com/view/b7725b2a874769eae009581b6bd97f192279bf99.html

#### 进阶：按层模拟 O(mn), O(1)

```
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return list()
        
        rows, columns = len(matrix), len(matrix[0])
        order = list()
        left, right, top, bottom = 0, columns - 1, 0, rows - 1
        while left <= right and top <= bottom:
            for column in range(left, right + 1):
                order.append(matrix[top][column])
            for row in range(top + 1, bottom + 1):
                order.append(matrix[row][right])
            if left < right and top < bottom:
                for column in range(right - 1, left, -1):
                    order.append(matrix[bottom][column])
                for row in range(bottom, top, -1):
                    order.append(matrix[row][left])
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1
        return order
```

### [113] 路径总和

#### 入门：DFS O(n^2), O(n)
```
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:
        ret = list()
        path = list()
        
        def dfs(root: TreeNode, targetSum: int):
            if not root:
                return
            path.append(root.val)
            targetSum -= root.val
            if not root.left and not root.right and targetSum == 0:
                ret.append(path[:])
            dfs(root.left, targetSum)
            dfs(root.right, targetSum)
            path.pop()
        
        dfs(root, targetSum)
        return ret

```

#### 入门：BFS O(n^2), O(n)

> from collections import defaultdict  
> collections.defaultdict(lambda: None)
 
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:
        res = []
        que = deque()
        que.append((root, [], 0)) # 将要处理的节点，路径，路径和
        while que:
            node, path, pathSum = que.popleft()
            if not node: # 如果是空节点，不处理
                continue
            if not node.left and not node.right: # 如果是叶子节点
                if node.val + pathSum == sum: # 加上叶子节点后，路径和等于sum
                    res.append(path + [node.val]) # 保存路径
            # 处理左子树
            que.append((node.left, path + [node.val], pathSum + node.val))
            # 处理右子树
            que.append((node.right, path + [node.val], pathSum + node.val))
        return res
```


### [92] 反转链表II

#### 入门：穿针引线 O(n), O(1)

```
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        def reverse_linked_list(head: ListNode):
            # 也可以使用递归反转一个链表
            pre = None
            cur = head
            while cur:
                next = cur.next
                cur.next = pre
                pre = cur
                cur = next

        # 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
        dummy_node = ListNode(-1)
        dummy_node.next = head
        pre = dummy_node
        # 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        # 建议写在 for 循环里，语义清晰
        for _ in range(left - 1):
            pre = pre.next

        # 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        right_node = pre
        for _ in range(right - left + 1):
            right_node = right_node.next
        # 第 3 步：切断出一个子链表（截取链表）
        left_node = pre.next
        curr = right_node.next

        # 注意：切断链接
        pre.next = None
        right_node.next = None

        # 第 4 步：同第 206 题，反转链表的子区间
        reverse_linked_list(left_node)
        # 第 5 步：接回到原来的链表中
        pre.next = right_node
        left_node.next = curr
        return dummy_node.next
```


#### 进阶：穿针引线+头插 O(n), O(1)
虽然都是O(n),但时间复杂度相比上面在最坏情况下也是一遍遍历而已

```
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        # 设置 dummyNode 是这一类问题的一般做法
        dummy_node = ListNode(-1)
        dummy_node.next = head
        pre = dummy_node
        for _ in range(left - 1):
            pre = pre.next

        cur = pre.next
        for _ in range(right - left):
            next = cur.next
            cur.next = next.next
            next.next = pre.next
            pre.next = next
        return dummy_node.next
```


### [470] 用 Rand7() 实现 Rand10()

> 简单来说，就是通过扩展数据范围，找到等概率事件，其他无关的遇到了，就直接放弃
#### 入门：拒绝采样 O(1), O(1)

```
class Solution:
    def rand10(self) -> int:
        while True:
            row = rand7()
            col = rand7()
            idx = (row - 1) * 7 + col
            if idx <= 40:
                return 1 + (idx - 1) % 10
```

#### 进阶：拒绝采样 O(1), O(1)

```
class Solution:
    def rand10(self) -> int:
        while True:
            a = rand7()
            b = rand7()
            idx = (a - 1) * 7 + b
            if idx <= 40:
                return 1 + (idx - 1) % 10
            a = idx - 40
            b = rand7()
            # get uniform dist from 1 - 63
            idx = (a - 1) * 7 + b
            if idx <= 60:
                return 1 + (idx - 1) % 10
            a = idx - 60
            b = rand7()
            # get uniform dist from 1 - 21
            idx = (a - 1) * 7 + b
            if idx <= 20:
                return 1 + (idx - 1) % 10
```

### [240] 搜索矩阵 II

#### 入门：暴力 mn, 1
```
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        for row in matrix:
            for element in row:
                if element == target:
                    return True
        return False
```
#### 进阶：二分查找 mlogn， 1


```
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        for row in matrix:
            idx = bisect.bisect_left(row, target)
            if idx < len(row) and row[idx] == target:
                return True
        return False
```

#### 亮点：Z字查找 m+n ， 1
```
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m, n = len(matrix), len(matrix[0])
        x, y = 0, n - 1
        while x < m and y >= 0:
            if matrix[x][y] == target:
                return True
            if matrix[x][y] > target:
                y -= 1
            else:
                x += 1
        return False
```

### [79] 单词搜索

#### 入门：回溯 O(mn), O(min(l,mn))

> 解释：https://leetcode.cn/problems/word-search/solution/shen-du-you-xian-sou-suo-yu-hui-su-xiang-jie-by-ja/

```
class Solution(object):
    
    # 定义上下左右四个行走方向
    directs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        m = len(board)
        if m == 0:
            return False
        n = len(board[0])
        mark = [[0 for _ in range(n)] for _ in range(m)]
                
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == word[0]:
                    # 将该元素标记为已使用
                    mark[i][j] = 1
                    if self.backtrack(i, j, mark, board, word[1:]) == True:
                        return True
                    else:
                        # 回溯
                        mark[i][j] = 0
        return False
        
        
    def backtrack(self, i, j, mark, board, word):
        if len(word) == 0:
            return True
        
        for direct in self.directs:
            cur_i = i + direct[0]
            cur_j = j + direct[1]
            
            if cur_i >= 0 and cur_i < len(board) and cur_j >= 0 and cur_j < len(board[0]) and board[cur_i][cur_j] == word[0]:
                # 如果是已经使用过的元素，忽略
                if mark[cur_i][cur_j] == 1:
                    continue
                # 将该元素标记为已使用
                mark[cur_i][cur_j] = 1
                if self.backtrack(cur_i, cur_j, mark, board, word[1:]) == True:
                    return True
                else:
                    # 回溯
                    mark[cur_i][cur_j] = 0
        return False
```

### [34] 单词搜索
> 二分模板：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/lan-hong-hua-fen-fa-dan-mo-ban-miao-sha-e7r40/
 

#### 入门：二分优化 O(logn), O(1)
找到目标值的时候先不用停，因为搜索区间

```
class Solution:

    # 寻找左边界
    def leftMargin(self, nums: List[int], target: int):

        low, high = 0, len(nums) - 1

        while low <= high:
            mid = low + (high - low) // 2

            # 如果 nums[mid] = target，继续向左寻找左边界
            if nums[mid] == target:
                high = mid - 1
            elif nums[mid] > target:
                high = mid - 1
            else:
                low = mid + 1
        if nums[low] == target:
            return low
        # 如果左边界的值不等于 target
        else:
            return -1

    # 寻找右边界
    def rightMargin(self, nums: List[int], target: int):

        low, high = 0, len(nums) - 1

        while low <= high:
            mid = low + (high - low) // 2

            # 如果 nums[mid] = traget，继续向右寻找右边界
            if nums[mid] == target:
                low = mid + 1
            elif nums[mid] > target:
                high = mid - 1
            else:
                low = mid + 1
        if nums[high] == target:
            return high
        # 如果右边界的值不等于 target
        else:
            return -1

    def searchRange(self, nums: List[int], target: int) -> List[int]:

        if len(nums) == 0 or nums[0] > target or nums[-1] < target:
            return [-1,-1]

        lm = self.leftMargin(nums, target)
        rm = self.rightMargin(nums, target)

        return [lm,rm]
```

### [15] 三数之和

#### 入门：排序 + 双指针 O(n^2), O(1)
> 难点在于如何去除重复解。

```
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        
        n=len(nums)
        res=[]
        if(not nums or n<3):
            return []
        nums.sort()
        res=[]
        for i in range(n):
            if(nums[i]>0):
                return res
            # 遇到重复值就跳过
            if(i>0 and nums[i]==nums[i-1]):
                continue
            L=i+1
            R=n-1
            while(L<R):
                if(nums[i]+nums[L]+nums[R]==0):
                    # 不止一组值，需要多次遍历
                    res.append([nums[i],nums[L],nums[R]])
                    # 遇到重复值就跳过
                    while(L<R and nums[L]==nums[L+1]):
                        L=L+1
                    while(L<R and nums[R]==nums[R-1]):
                        R=R-1
                    L=L+1
                    R=R-1
                elif(nums[i]+nums[L]+nums[R]>0):
                    R=R-1
                else:
                    L=L+1
        return res
```

### [103] 二叉树的锯齿形层序遍历

#### 入门：BFS O(n), O(1)

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        ans = []
        if not root:
            return ans

        stack = [root]
        order = 1
        while stack:
            nex = [] 
            # 遍历的时候是传统BFS，但打印区分奇偶层
            if order: 
                ans.append([node.val for node in stack])
            else:
                ans.append([node.val for node in stack][::-1])
            order = 1-order

            for node in stack:
                if node.left:
                    nex.append(node.left)
                if node.right:
                    nex.append(node.right)
            stack = nex
        return ans
```

### [1] 两数之和

#### 入门：哈希，两次遍历，故意示弱 O(n), O(n)

```
def twoSum(nums, target):
    hashmap={}
    # 因为只有一组答案，所有用数字作为key就好
    for ind,num in enumerate(nums):
        hashmap[num] = ind
    for i,num in enumerate(nums):
        j = hashmap.get(target - num)
        if j is not None and i!=j:
            return [i,j]
```

#### 进阶：哈希，一次遍历 O(n), O(n)

```
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashtable = dict()
        for i, num in enumerate(nums):
            if target - num in hashtable:
                return [hashtable[target - num], i]
            hashtable[nums[i]] = i
        return []
```

### [215] 数组中的第K个最大元素

#### 入门：快排+分治 O(n), O(logn)

```
1、随机选取一个初始值pivot，遍历一遍数组，将小于pivot的，等于pivot的，大于pivot的分别放到left，mid,right数组中。
2、判断len(right)是否>=k，要是大于则证明第k大的元素必存在于right数组中，此时只需要递归执行pivot = quickselect(right,k)
3、判断len(right) + len(mid) 是否 < k，要是小于则证明第k大的元素必存在于left数组中，此时只需要找到left数组中第k-len(right)-len(mid)大的元素即可，此时递归执行pivot = quickselect(left,k-len(right)-len(mid))
4、若不满足2，3则证明pivot就是第k大的元素，return pivot即可。

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # 根据快排算法改进的快速选择算法
        res = 0
        def quickselect(mylist,k):
            randomIndex = random.randint(0,len(mylist)-1)
            pivot = mylist[randomIndex]
            left = []
            right = []
            mid = []
            for i in mylist:
                if i < pivot:
                    left.append(i)
                elif i > pivot:
                    right.append(i)
                elif i == pivot:
                    mid.append(i)

            if len(right) >= k:
                pivot = quickselect(right,k)

            elif len(right) + len(mid) < k:
                pivot = quickselect(left,k-len(right)-len(mid))

            return pivot
        r = quickselect(nums,k)
        return r
```
#### 进阶：二叉堆排序+分治理 O(nlogn), O(logn)


```
import heapq as h

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        heap = []

        for num in nums:
            # 如果堆长度没到k，无脑塞
            if len(heap) < k:
                h.heappush(heap, num)
            else:
                # 如果长度到k了，且当前元素比堆顶要大，我们才加进去，当然要先把最小的pop出来再加！
                if num > heap[0]:
                    h.heappop(heap)
                    h.heappush(heap, num)
        return h.heappop(heap)
```


#### 亮点：手写二叉堆排序+分治理 O(nlogn), O(logn)

> 模板：二叉堆

```
class Heap:
    def __init__(self, length):
        self.heap = [0] * (length + 1)
        self.size = 0
    
    def push(self, val):
        if self.size == len(self.heap) - 1:
            return False
        self.size += 1
        self.heap[self.size] = val
        self.shift_up(self.size)
        return True
    
    def pop(self):
        val = self.heap[1]
        self.heap[1] = self.heap[self.size]
        self.heap[self.size] = 0
        self.size -= 1
        self.shift_down(1)
        return val
    
    def peek(self):
        return self.heap[1]
    
    def shift_up(self, i):
        val = self.heap[i]
        while i >> 1 > 0:
            parent = i >> 1
            if val < self.heap[parent]:
                self.heap[i] = self.heap[parent]
                i = parent
            else:
                break
        self.heap[i] = val
    
    def shift_down(self, i):
        val = self.heap[i]
        while i << 1 <= self.size:
            child = i << 1
            if child != self.size and self.heap[child + 1] < self.heap[child]:
                child += 1
            if val > self.heap[child]:
                self.heap[i] = self.heap[child]
                i = child
            else:
                break
        self.heap[i] = val
```


```
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        heap = Heap(k + 1)
        for num in nums:
            if not heap.push(num):
                heap.pop()
                heap.push(num)
        if heap.size == k + 1:
            heap.pop()
        return heap.peek()
        
class Heap:
    def __init__(self, length):
        self.heap = [0] * (length + 1)
        self.size = 0
    
    def push(self, val):
        if self.size == len(self.heap) - 1:
            return False
        self.size += 1
        self.heap[self.size] = val
        self.shift_up(self.size)
        return True
    
    def pop(self):
        val = self.heap[1]
        self.heap[1] = self.heap[self.size]
        self.heap[self.size] = 0
        self.size -= 1
        self.shift_down(1)
        return val
    
    def peek(self):
        return self.heap[1]
    
    def shift_up(self, i):
        val = self.heap[i]
        while i >> 1 > 0:
            parent = i >> 1
            if val < self.heap[parent]:
                self.heap[i] = self.heap[parent]
                i = parent
            else:
                break
        self.heap[i] = val
    
    def shift_down(self, i):
        val = self.heap[i]
        while i << 1 <= self.size:
            child = i << 1
            if child != self.size and self.heap[child + 1] < self.heap[child]:
                child += 1
            if val > self.heap[child]:
                self.heap[i] = self.heap[child]
                i = child
            else:
                break
        self.heap[i] = val
```

### [53] 最大子序列和

#### 入门：分治 O(n), O(n)

```
1.确定讨论区间 [left, mid]，[mid + 1, right]，包含子区间 [mid , mid + 1] 的子区间（即 nums[mid] 与 nums[mid + 1] 一定会被选取）
2.求解三者最大值

from typing import List


class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        size = len(nums)
        if size == 0:
            return 0
        return self.__max_sub_array(nums, 0, size - 1)

    def __max_sub_array(self, nums, left, right):
        if left == right:
            return nums[left]
        mid = (left + right) >> 1
        return max(self.__max_sub_array(nums, left, mid),
                   self.__max_sub_array(nums, mid + 1, right),
                   self.__max_cross_array(nums, left, mid, right))

    def __max_cross_array(self, nums, left, mid, right):
        # 一定包含 nums[mid] 元素的最大连续子数组的和，
        # 思路是看看左边"扩散到底"，得到一个最大数，右边"扩散到底"得到一个最大数
        # 然后再加上中间数
        left_sum_max = 0
        start_left = mid - 1
        s1 = 0
        while start_left >= left:
            s1 += nums[start_left]
            left_sum_max = max(left_sum_max, s1)
            start_left -= 1

        right_sum_max = 0
        start_right = mid + 1
        s2 = 0
        while start_right <= right:
            s2 += nums[start_right]
            right_sum_max = max(right_sum_max, s2)
            start_right += 1
        return left_sum_max + nums[mid] + right_sum_max
```

#### 进阶：直接DP O(n), O(n)
> 时间复杂度n好过nlogn，但logn好过n

```
1.定义dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。
2.定义转移方程
	dp[i]	=	
	{ 
		dp[i−1]+nums[i], if dp[i−1]>0
		nums[i], 		 if dp[i−1]≤0
	}
3.定义边界dp[0] = nums[0]
4.循环求解

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        size = len(nums)
        if size == 0:
            return 0
        dp = [0 for _ in range(size)]

        dp[0] = nums[0]
        for i in range(1, size):
            if dp[i - 1] >= 0:
                dp[i] = dp[i - 1] + nums[i]
            else:
                dp[i] = nums[i]
        return max(dp)
```

#### 亮点：优化空间的DP O(n), O(1)

```
1.不用预先开辟内存空间

from typing import List


class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        size = len(nums)
        pre = 0
        res = nums[0]
        # 省去的dp = [0 for _ in range(size)]开辟的额外空间
        for i in range(size):
            pre = max(nums[i], pre + nums[i])
            res = max(res, pre)
        return res
```

### [141] 环形链表

#### 入门：哈希 O(n), O(n)

```
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        seen = set()
        while head:
            if head in seen:
                return True
            seen.add(head)
            head = head.next
        return False
```

#### 进阶：快慢指针 O(n), O(1)

```
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if not head or not head.next:
            return False
        
        slow = head
        fast = head.next

        while slow != fast:
            if not fast or not fast.next:
                return False
            slow = slow.next
            fast = fast.next.next
        
        return True
```

### [21] 环形链表

#### 入门：递归 O(n+m), O(n+m)

```
1.两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if l1 is None:
            return l2
        elif l2 is None:
            return l1
        elif l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

#### 入门：迭代 O(n+m), O(1)

```
1.定义prehead，prev指针
2.如果 l1.val<= l2.val ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。
3.拼接非空的链接到最后

就新建一个节点，后面都是原来的节点拼接过来，所以空间复杂度是O(n)
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        prehead = ListNode(-1)

        prev = prehead
        while l1 and l2:
            if l1.val <= l2.val:
                prev.next = l1
                l1 = l1.next
            else:
                prev.next = l2
                l2 = l2.next            
            prev = prev.next

        # 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        prev.next = l1 if l1 is not None else l2

        return prehead.next
```

### [151] 翻转字符串里的单词

#### 入门：双端队列 O(n), O(n)
> 技巧：新建collections.deque()，头插appendleft，尾插append，' '.join(d)每个都拼一个空格

```
" ".join(reversed(s.split()))：调API的方法直接pass吧

class Solution:
    def reverseWords(self, s: str) -> str:
        left, right = 0, len(s) - 1
        # 去掉字符串开头的空白字符
        while left <= right and s[left] == ' ':
            left += 1
        
        # 去掉字符串末尾的空白字符
        while left <= right and s[right] == ' ':
            right -= 1
            
        d, word = collections.deque(), []
        # 将单词 push 到队列的头部
        while left <= right:
            if s[left] == ' ' and word:
                d.appendleft(''.join(word))
                word = []
            elif s[left] != ' ':
                word.append(s[left])
            left += 1
        d.appendleft(''.join(word))
        
        return ' '.join(d)
```

### [46] 全排列

#### 入门：双端队列 O(n), O(n)
> 技巧：新建collections.deque()，头插appendleft，尾插append，' '.join(d)每个都拼一个空格

```
" ".join(reversed(s.split()))：调API的方法直接pass吧

class Solution:
    def reverseWords(self, s: str) -> str:
        left, right = 0, len(s) - 1
        # 去掉字符串开头的空白字符
        while left <= right and s[left] == ' ':
            left += 1
        
        # 去掉字符串末尾的空白字符
        while left <= right and s[right] == ' ':
            right -= 1
            
        d, word = collections.deque(), []
        # 将单词 push 到队列的头部
        while left <= right:
            if s[left] == ' ' and word:
                d.appendleft(''.join(word))
                word = []
            elif s[left] != ' ':
                word.append(s[left])
            left += 1
        d.appendleft(''.join(word))
        
        return ' '.join(d)
```

### [98] 验证二叉树

#### 入门：递归 O(n), O(n)


```
class Solution:
    def isValidBST(self, root):
        
        def BFS(root, left, right):
            if root is None:
                return True
            
            if left < root.val < right:
                return BFS(root.left, left, root.val) and BFS(root.right, root.val, right)
            else:
                return False

        return BFS(root, -float('inf'), float('inf'))
```

#### 进阶：中序遍历 O(n), O(n)

```
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack, inorder = [], float('-inf')
        
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                tmp = stack.pop()
                # 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
                if tmp.val <= inorder:
                    return False
                inorder = tmp.val
                root = tmp.right               
        return True
```

### [165] 比较版本号

#### 入门：暴力 O(n+m), O(n+m)

> 技巧：zip_longest适用于两组元素既需要拆解又需要比较

```
class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        for v1, v2 in zip_longest(version1.split('.'), version2.split('.'), fillvalue=0):
            x, y = int(v1), int(v2)
            if x != y:
                return 1 if x > y else -1
        return 0
```

#### 进阶：双指针 O(n+m), O(1)


```
class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        n, m = len(version1), len(version2)
        i, j = 0, 0
        while i < n or j < m:
            x = 0
            while i < n and version1[i] != '.':
                x = x * 10 + ord(version1[i]) - ord('0')
                i += 1
            i += 1  # 跳过点号
            y = 0
            while j < m and version2[j] != '.':
                y = y * 10 + ord(version2[j]) - ord('0')
                j += 1
            j += 1  # 跳过点号
            if x != y:
                return 1 if x > y else -1
        return 0
```


### [234] 回文链表

#### 入门：快慢指针 O(n), O(1)


```
怎么感觉涉及圈圈和循环的题，都可以用快慢指针

1、找到前半部分链表的尾节点。
2、反转后半部分链表。
3、判断是否回文。
4、恢复链表。

class Solution:

    def isPalindrome(self, head: ListNode) -> bool:
        if head is None:
            return True

        # 找到前半部分链表的尾节点并反转后半部分链表
        first_half_end = self.end_of_first_half(head)
        second_half_start = self.reverse_list(first_half_end.next)

        # 判断是否回文
        result = True
        first_position = head
        second_position = second_half_start
        while result and second_position is not None:
            if first_position.val != second_position.val:
                result = False
            first_position = first_position.next
            second_position = second_position.next

        # 还原链表并返回结果
        first_half_end.next = self.reverse_list(second_half_start)
        return result    

	 # 快慢指针寻找交叉点
	 # 若链表有奇数个节点，则中间的节点应该看作是前半部分
    def end_of_first_half(self, head):
        fast = head
        slow = head
        while fast.next is not None and fast.next.next is not None:
            fast = fast.next.next
            slow = slow.next
        return slow

	 # 反转链表-迭代
    def reverse_list(self, head):
        previous = None
        current = head
        while current is not None:
            next_node = current.next
            current.next = previous
            previous = current
            current = next_node
        return previous
        
    # 反转链表-递归    
    def reverse_list(self, head):
		"""
		:type head: ListNode
		:rtype: ListNode
		"""
		# 递归终止条件是当前为空，或者下一个节点为空
		if(head==None or head.next==None):
			return head
		# 这里的cur就是最后一个节点
		cur = self.reverseList(head.next)
		# 这里请配合动画演示理解
		# 如果链表是 1->2->3->4->5，那么此时的cur就是5
		# 而head是4，head的下一个是5，下下一个是空
		# 所以head.next.next 就是5->4
		head.next.next = head
		# 防止链表循环，需要将head.next设置为空
		head.next = None
		# 每层递归函数都返回cur，也就是最后一个节点
		return cur
```

### [41] 缺失的第一个正数

#### 入门：原地哈希 O(n), O(1)

```
整体思路：相当于将值映射成哈希表的下标
1、我们将数组中所有小于等于0的数修改为N+1（对于一个长度为N的数组，其中没有出现的最小正整数只能在[1,N+1] 中。这是因为如果[1, N]都出现了，那么答案是N+1）；
2、我们遍历数组中的每一个数 x，它可能已经被打了标记，因此原本对应的数为 |x|，其中∣∣为绝对值符号。如果|x|∈[1, N]，那么我们给数组中的第∣x∣−1 个位置的数添加一个负号。注意如果它已经有负号，不需要重复添加；
3、在遍历完成之后，如果数组中的每一个数都是负数，那么答案是N+1，否则答案是第一个正数的位置加1。

class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        for i in range(n):
            if nums[i] <= 0:
                nums[i] = n + 1
        
        for i in range(n):
            num = abs(nums[i])
            if num <= n:
                nums[num - 1] = -abs(nums[num - 1])
        
        for i in range(n):
            if nums[i] > 0:
                return i + 1
        
        return n + 1
```

### [23] 合并K个升序链表

#### 入门：两两合并 O(k^2*n), O(1)


```
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists: return None
        res = None #设置初始结果为空
        for listi in lists: #逐个遍历 两两合并
            res = self.mergeTwoLists(res, listi)
        return res
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0) #构造虚节点
        move = dummy #设置移动节点等于虚节点
        while l1 and l2: #都不空时
            if l1.val < l2.val:
                move.next = l1 #移动节点指向数小的链表
                l1 = l1.next
            else:
                move.next = l2
                l2 = l2.next
            move = move.next
        move.next = l1 if l1 else l2 #连接后续非空链表
        return dummy.next #虚节点仍在开头
```

#### 进阶：归并合并 O(kn*logk), O(logk)


```
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists: return None
        n = len(lists) #记录子链表数量
        return self.mergeSort(lists, 0, n - 1) #调用归并排序函数
    def mergeSort(self, lists: List[ListNode], l: int, r: int) -> ListNode:
        if l == r:
            return lists[l]
        m = (l + r) // 2
        L = self.mergeSort(lists, l, m) #循环的递归部分
        R = self.mergeSort(lists, m + 1, r)
        return self.mergeTwoLists(L, R) #调用两链表合并函数
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0) #构造虚节点
        move = dummy #设置移动节点等于虚节点
        while l1 and l2: #都不空时
            if l1.val < l2.val:
                move.next = l1 #移动节点指向数小的链表
                l1 = l1.next
            else:
                move.next = l2
                l2 = l2.next
            move = move.next
        move.next = l1 if l1 else l2 #连接后续非空链表
        return dummy.next #虚节点仍在开头
```

#### 亮点：堆排，优先队列 O(logk), O(k)



```
需要手写堆排方法

class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        import heapq #调用堆
        minHeap = []
        for listi in lists: 
            while listi:
                heapq.heappush(minHeap, listi.val) #把listi中的数据逐个加到堆中
                listi = listi.next
        dummy = ListNode(0) #构造虚节点
        p = dummy
        while minHeap:
            p.next = ListNode(heapq.heappop(minHeap)) #依次弹出最小堆的数据
            p = p.next
        return dummy.next 
        
   def heapq.heappush():
   
   def heapq.heappop():
   
```

### [114] 二叉树展开链表

#### 入门：前序遍历 O(n), O(n)


```
class Solution:
    def flatten(self, root: TreeNode) -> None:
        preorderList = list()
        stack = list()
        node = root

        while node or stack:
            while node:
                preorderList.append(node)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        
        size = len(preorderList)
        for i in range(1, size):
            prev, curr = preorderList[i - 1], preorderList[i]
            prev.left = None
            prev.right = curr
```

#### 进阶：原地遍历 O(n), O(1)
```
class Solution:
    def flatten(self, root: TreeNode) -> None:
        curr = root
        while curr:
            if curr.left:
                predecessor = nxt = curr.left
                while predecessor.right:
                    predecessor = predecessor.right
                predecessor.right = curr.right
                curr.left = None
                curr.right = nxt
            curr = curr.right
```

### [739] 每日温度

#### 入门：单调栈 O(n), O(n)

```
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        length = len(temperatures)
        ans = [0] * length
        stack = []
        for i in range(length):
            temperature = temperatures[i]
            while stack and temperature > temperatures[stack[-1]]:
                prev_index = stack.pop()
                ans[prev_index] = i - prev_index
            stack.append(i)
        return ans
```