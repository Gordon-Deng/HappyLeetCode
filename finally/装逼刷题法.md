# 装逼刷题法

### [3] 无重复字符的最长子串

```
https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

#### 通用：滑动窗口 O(N)，O(∣Σ∣)，其中Σ表示字符集（即字符串中可以出现的字符）
```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 哈希集合，记录每个字符是否出现过
        occ = set()
        n = len(s)
        # 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        rk, ans = -1, 0
        for i in range(n):
            if i != 0:
                # 左指针向右移动一格，移除一个字符
                occ.remove(s[i - 1])
            while rk + 1 < n and s[rk + 1] not in occ:
                # 不断地移动右指针
                occ.add(s[rk + 1])
                rk += 1
            # 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = max(ans, rk - i + 1)
        return ans
```

### [42] 接雨水
```
https://leetcode-cn.com/problems/trapping-rain-water/description/

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

示例:

输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```
#### Low: 单调栈 O(n)，O(n)
```
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        stack = list()
        n = len(height)
        
        for i, h in enumerate(height):
            while stack and h > height[stack[-1]]:
                top = stack.pop()
                if not stack:
                    break
                left = stack[-1]
                currWidth = i - left - 1
                currHeight = min(height[left], height[i]) - height[top]
                ans += currWidth * currHeight
            stack.append(i)
        
        return ans
```

#### High: 双指针 O(n)，O(1)
左右高度，小的为王，同侧相减，加进总和

```
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        left, right = 0, len(height) - 1
        leftMax = rightMax = 0

        while left < right:
            leftMax = max(leftMax, height[left])
            rightMax = max(rightMax, height[right])
            if height[left] < height[right]:
                ans += leftMax - height[left]
                left += 1
            else:
                ans += rightMax - height[right]
                right -= 1
        
        return ans
```

### [121] 买卖股票的最佳时机系列

```
真特么牛逼
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
⁠    注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。


示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

我们要跳出固有的思维模式，并不是要考虑买还是卖，而是要最大化手里持有的钱。
买股票手里的钱减少，卖股票手里的钱增加，无论什么时刻，我们要保证手里的钱最多。

我们这一次买还是卖只跟上一次我们卖还是买的状态有关。

#### 121. 买卖股票的最佳时机
```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        buy, sell = -float("inf"), 0

        for p in prices:
            buy = max(buy, 0 - p)
            sell = max(sell, buy + p)

        return sell
```

#### 122. 买卖股票的最佳时机
这两个问题唯一的不同点在于我们是买一次还是买无穷多次，而代码就只有 0-p 和 sell-p 的区别。
因为如果买无穷多次，就需要上一次卖完的状态。如果只买一次，那么上一个状态一定是0。

```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        buy, sell = -float("inf"), 0

        for p in prices:
            buy = max(buy, sell - p)
            sell = max(sell, buy + p)

        return sell

```

#### 123. 买卖股票的最佳时机
这题只允许最多买两次，那么就有四个状态，第一次买，第一次卖，第二次买，第二次卖。
还是那句话，无论什么状态，我们要保证手里的钱最多。

```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        b1, b2, s1, s2 = -float("inf"), -float("inf"), 0, 0

        for p in prices:
            b1 = max(b1, 0 - p)
            s1 = max(s1, b1 + p)
            b2 = max(b2, s1 - p)
            s2 = max(s2, b2 + p)
            
        return s2
```

#### 188. 买卖股票的最佳时机
上三题最多两次我们有2x2个状态，那么k次我们就需要kx2个状态。
那么我们并不需要像第三题那样真的列kx2个参数，我们只需要两个数组就可以了。

```
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        k = min(k, len(prices) // 2)

        buy = [-float("inf")] * (k+1)
        sell = [0] * (k+1)

        for p in prices:
            for i in range(1, k+1):
                buy[i] = max(buy[i], sell[i-1] - p)
                sell[i] = max(sell[i], buy[i] + p)

        return sell[-1]

```

#### 309. 最佳买卖股票时机含冷冻期
这道题只是122的变形，卖完要隔一天才能买，那么就多记录上一次卖的状态即可。


```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        buy, sell_pre, sell = -float("inf"), 0, 0

        for p in prices:
            buy = max(buy, sell_pre - p)
            sell_pre, sell = sell, max(sell, buy + p)
                 
        return sell
```

#### 714. 买卖股票的最佳时机含手续费
每次买卖需要手续费，那么我们买的时候减掉手续费就行了。

```
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:

        buy, sell = -float("inf"), 0

        for p in prices:
            buy = max(buy, sell - p - fee)
            sell = max(sell, buy + p)
        
        return sell
```
### [199] 二叉树的右视图

```
https://leetcode-cn.com/problems/binary-tree-right-side-view/description/

algorithms
Medium (64.92%)
Likes:    507
Dislikes: 0
Total Accepted:    124.2K
Total Submissions: 191K
Testcase Example:  '[1,2,3,null,5,null,4]'

给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。



示例 1:




输入: [1,2,3,null,5,null,4]
输出: [1,3,4]


示例 2:


输入: [1,null,3]
输出: [1,3]
```

#### 层次遍历+hashmap巧取同层最后一个 

```
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        rightmost_value_at_depth = dict() # 深度为索引，存放节点的值
        max_depth = -1

        queue = deque([(root, 0)])
        while queue:
            node, depth = queue.popleft()

            if node is not None:
                # 维护二叉树的最大深度
                max_depth = max(max_depth, depth)

                # 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可
                rightmost_value_at_depth[depth] = node.val

                queue.append((node.left, depth + 1))
                queue.append((node.right, depth + 1))

        return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]
```


#### 反向层次遍历+setdefault

```
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        rightmost_value_at_depth = dict() # 深度为索引，存放节点的值
        max_depth = -1

        queue = deque([(root, 0)])
        while queue:
            node, depth = queue.popleft()

            if node is not None:
                # 维护二叉树的最大深度
                max_depth = max(max_depth, depth)

                # setdefault相当于get, 不改变原有值，除非没有key
                rightmost_value_at_depth.setdefault(depth, node.val)
                
                # 从右到左
                queue.append((node.right, depth + 1))
                queue.append((node.left, depth + 1))

        return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]
```

### 剑指 Offer 12. 矩阵中的路径

```
https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
示例 2：

输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

#### LOW 基础回溯+DFS

```
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(i, j, k):
            # 用来判断程序是否越界，还有第一个字母是否匹配，第一个都不匹配直接返回False
            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k]:  return False
            # 当程序跑到word的最后一个字母时，这时无需再dfs，直接返回True
            if k == len(word) - 1: return True
            # 把访问过的字母标记为空，这样可以避免程序多次访问同一元素
            board[i][j] = ""
            # 剪枝顺序：下、上、右、左
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            # 一趟dfs结束后把原来设的空改回来，以免影响后面的dfs遍历使用
            board[i][j] = word[k]
            return res 
        # 一个一个字母来尝试，每一次尝试都是dfs遍历成功的一种可能性
        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i, j, 0): return True
        # 遍历完成，仍没有成功的路径，返回False
        return False
```

#### High 问是否支持变更数组，上面解法其实已经支持无修改原数组，但问多一句有好处
```
```

### [232] 用栈实现队列

```
https://leetcode-cn.com/problems/implement-queue-using-stacks/description/

algorithms
Easy (68.87%)
Likes:    446
Dislikes: 0
Total Accepted:    142.3K
Total Submissions: 206.2K
Testcase Example:  '["MyQueue","push","push","peek","pop","empty"]\n[[],[1],[2],[],[],[]]'

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：


void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false

说明：
你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty
操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

进阶：

你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。
示例：

输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false

提示：
最多调用 100 次 push、pop、peek 和 empty
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）
```

#### O(1), O(1)

```
class MyQueue:
    def __init__(self):
        self.stack1 = list()
        self.stack2 = list()

    def push(self, x: int) -> None:
        # self.stack1用于接受元素
        self.stack1.append(x)

    def pop(self) -> int:
        # self.stack2用于弹出元素，如果self.stack2为[],则将self.stack1中元素全部弹出给self.stack2
        if self.stack2 == []:
            while self.stack1:
                tmp = self.stack1.pop()
                self.stack2.append(tmp)
        return self.stack2.pop()

    def peek(self) -> int:
        if self.stack2 == []:
            while self.stack1:
                tmp = self.stack1.pop()
                self.stack2.append(tmp)
        return self.stack2[-1]

    def empty(self) -> bool:
        return self.stack1 == [] and self.stack2 == []
```

### [155] 最小栈
没啥好说的，基础python中取队列尾部用下标-1就OK

```
https://leetcode-cn.com/problems/min-stack/description/
设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) -- 将元素 x 推入栈中。
pop() -- 删除栈顶的元素。
top() -- 获取栈顶元素。
getMin() -- 检索栈中的最小元素。
```

#### 双栈：O(1）,O(N)
```
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, x: int) -> None:
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]: 
            self.min_stack.append(x)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

### [105] 从前序与中序遍历序列构造二叉树

```
https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/

algorithms
Medium (69.68%)
Likes:    1038
Dislikes: 0
Total Accepted:    193.8K
Total Submissions: 278.1K
Testcase Example:  '[3,9,20,15,7]\n[9,3,15,20,7]'

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：

⁠   3
⁠  / \
⁠ 9  20
⁠   /  \
⁠  15   7



@lc code=start
Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

#### 入门：递归 O(N) 、O(N)
```
list.index(列表中某个值) 求下标

```
```
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder or not inorder:  # 递归终止条件
            return
        root = TreeNode(preorder[0])  # 先序为“根左右”，所以根据preorder可以确定root
        idx = inorder.index(preorder[0])  # 中序为“左根右”，根据root可以划分出左右子树
        # 下面递归对root的左右子树求解即可
        root.left = self.buildTree(preorder[1:1 + idx], inorder[:idx])
        root.right = self.buildTree(preorder[1 + idx:], inorder[idx + 1:])
        return root
```

#### 进阶：主动构造测试用例
```
# 构建树（将输入的列表转化为一棵二叉树，返回根节点）
def deserialize(data):
    def dfs(data):
        val = data.pop(0)
        if val == 'null':
            return None

        node = TreeNode(val)
        node.left = dfs(data)
        node.right = dfs(data)
        return node
    return dfs(data)
```


### [5] 最长回文子串
```
https://leetcode-cn.com/problems/longest-palindromic-substring/description/

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。


示例 2：

输入: "cbbd"
输出: "bb"
```

#### 入门： 二维数组DP + 夹层，O(N^2)、O(N^2)
遍历每个字符，让后定义一个函数从当前字符往两边走，前后指针处的字符相同则继续（要注意计数回文串和偶数回文串）

```
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        max_len, begin_index = 1, 0
        dp = [[False] * n for _ in range(n)]
        # if s[0] == s[1]:
        #     dp[0][1] = True

        for i in range(n):
            dp[i][i] = True
        for L in range(2, n+1):
            for i in range(n):
                j = L + i - 1
                if j >= n:
                    break
                if s[i] == s[j] and (j - i < 3):
                    dp[i][j] = True
                elif s[i] == s[j] and (j - i >= 3):
                    dp[i][j] = dp[i+1][j-1]

                if dp[i][j] and j - i + 1 > max_len:
                    max_len = j - i + 1
                    begin_index = i
        return s[begin_index:begin_index + max_len]
```