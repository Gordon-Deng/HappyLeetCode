# 装逼刷题法

### [3] 无重复字符的最长子串

```
https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

#### 通用：滑动窗口 O(N)，O(∣Σ∣)，其中Σ表示字符集（即字符串中可以出现的字符）
```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 哈希集合，记录每个字符是否出现过
        occ = set()
        n = len(s)
        # 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        rk, ans = -1, 0
        for i in range(n):
            if i != 0:
                # 左指针向右移动一格，移除一个字符
                occ.remove(s[i - 1])
            while rk + 1 < n and s[rk + 1] not in occ:
                # 不断地移动右指针
                occ.add(s[rk + 1])
                rk += 1
            # 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = max(ans, rk - i + 1)
        return ans
```

### [42] 接雨水
```
https://leetcode-cn.com/problems/trapping-rain-water/description/

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

示例:

输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```
#### Low: 单调栈 O(n)，O(n)
```
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        stack = list()
        n = len(height)
        
        for i, h in enumerate(height):
            while stack and h > height[stack[-1]]:
                top = stack.pop()
                if not stack:
                    break
                left = stack[-1]
                currWidth = i - left - 1
                currHeight = min(height[left], height[i]) - height[top]
                ans += currWidth * currHeight
            stack.append(i)
        
        return ans
```

#### High: 双指针 O(n)，O(1)
左右高度，小的为王，同侧相减，加进总和

```
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        left, right = 0, len(height) - 1
        leftMax = rightMax = 0

        while left < right:
            leftMax = max(leftMax, height[left])
            rightMax = max(rightMax, height[right])
            if height[left] < height[right]:
                ans += leftMax - height[left]
                left += 1
            else:
                ans += rightMax - height[right]
                right -= 1
        
        return ans
```

### [121] 买卖股票的最佳时机系列

```
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
⁠    注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。


示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

我们要跳出固有的思维模式，并不是要考虑买还是卖，而是要最大化手里持有的钱。
买股票手里的钱减少，卖股票手里的钱增加，无论什么时刻，我们要保证手里的钱最多。

我们这一次买还是卖只跟上一次我们卖还是买的状态有关。

#### 121. 买卖股票的最佳时机
```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        buy, sell = -float("inf"), 0

        for p in prices:
            buy = max(buy, 0 - p)
            sell = max(sell, buy + p)

        return sell
```

#### 122. 买卖股票的最佳时机
这两个问题唯一的不同点在于我们是买一次还是买无穷多次，而代码就只有 0-p 和 sell-p 的区别。
因为如果买无穷多次，就需要上一次卖完的状态。如果只买一次，那么上一个状态一定是0。

```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        buy, sell = -float("inf"), 0

        for p in prices:
            buy = max(buy, sell - p)
            sell = max(sell, buy + p)

        return sell

```

#### 123. 买卖股票的最佳时机
这题只允许最多买两次，那么就有四个状态，第一次买，第一次卖，第二次买，第二次卖。
还是那句话，无论什么状态，我们要保证手里的钱最多。

```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        b1, b2, s1, s2 = -float("inf"), -float("inf"), 0, 0

        for p in prices:
            b1 = max(b1, 0 - p)
            s1 = max(s1, b1 + p)
            b2 = max(b2, s1 - p)
            s2 = max(s2, b2 + p)
            
        return s2
```

#### 188. 买卖股票的最佳时机
上三题最多两次我们有2x2个状态，那么k次我们就需要kx2个状态。
那么我们并不需要像第三题那样真的列kx2个参数，我们只需要两个数组就可以了。

```
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        k = min(k, len(prices) // 2)

        buy = [-float("inf")] * (k+1)
        sell = [0] * (k+1)

        for p in prices:
            for i in range(1, k+1):
                buy[i] = max(buy[i], sell[i-1] - p)
                sell[i] = max(sell[i], buy[i] + p)

        return sell[-1]

```

#### 309. 最佳买卖股票时机含冷冻期
这道题只是122的变形，卖完要隔一天才能买，那么就多记录上一次卖的状态即可。


```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        buy, sell_pre, sell = -float("inf"), 0, 0

        for p in prices:
            buy = max(buy, sell_pre - p)
            sell_pre, sell = sell, max(sell, buy + p)
                 
        return sell
```

#### 714. 买卖股票的最佳时机含手续费
每次买卖需要手续费，那么我们买的时候减掉手续费就行了。

```
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:

        buy, sell = -float("inf"), 0

        for p in prices:
            buy = max(buy, sell - p - fee)
            sell = max(sell, buy + p)
        
        return sell
```